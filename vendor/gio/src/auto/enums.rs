// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib::StaticType;
use glib::Type;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib_ffi;
use gobject_ffi;

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DataStreamByteOrder {
    BigEndian,
    LittleEndian,
    HostEndian,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DataStreamByteOrder {
    type GlibType = ffi::GDataStreamByteOrder;

    fn to_glib(&self) -> ffi::GDataStreamByteOrder {
        match *self {
            DataStreamByteOrder::BigEndian => ffi::G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN,
            DataStreamByteOrder::LittleEndian => ffi::G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN,
            DataStreamByteOrder::HostEndian => ffi::G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN,
            DataStreamByteOrder::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDataStreamByteOrder> for DataStreamByteOrder {
    fn from_glib(value: ffi::GDataStreamByteOrder) -> Self {
        match value {
            0 => DataStreamByteOrder::BigEndian,
            1 => DataStreamByteOrder::LittleEndian,
            2 => DataStreamByteOrder::HostEndian,
            value => DataStreamByteOrder::__Unknown(value),
        }
    }
}

impl StaticType for DataStreamByteOrder {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_data_stream_byte_order_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DataStreamByteOrder {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DataStreamByteOrder {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DataStreamByteOrder {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DataStreamNewlineType {
    Lf,
    Cr,
    CrLf,
    Any,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DataStreamNewlineType {
    type GlibType = ffi::GDataStreamNewlineType;

    fn to_glib(&self) -> ffi::GDataStreamNewlineType {
        match *self {
            DataStreamNewlineType::Lf => ffi::G_DATA_STREAM_NEWLINE_TYPE_LF,
            DataStreamNewlineType::Cr => ffi::G_DATA_STREAM_NEWLINE_TYPE_CR,
            DataStreamNewlineType::CrLf => ffi::G_DATA_STREAM_NEWLINE_TYPE_CR_LF,
            DataStreamNewlineType::Any => ffi::G_DATA_STREAM_NEWLINE_TYPE_ANY,
            DataStreamNewlineType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GDataStreamNewlineType> for DataStreamNewlineType {
    fn from_glib(value: ffi::GDataStreamNewlineType) -> Self {
        match value {
            0 => DataStreamNewlineType::Lf,
            1 => DataStreamNewlineType::Cr,
            2 => DataStreamNewlineType::CrLf,
            3 => DataStreamNewlineType::Any,
            value => DataStreamNewlineType::__Unknown(value),
        }
    }
}

impl StaticType for DataStreamNewlineType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_data_stream_newline_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DataStreamNewlineType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DataStreamNewlineType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DataStreamNewlineType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FileType {
    Unknown,
    Regular,
    Directory,
    SymbolicLink,
    Special,
    Shortcut,
    Mountable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for FileType {
    type GlibType = ffi::GFileType;

    fn to_glib(&self) -> ffi::GFileType {
        match *self {
            FileType::Unknown => ffi::G_FILE_TYPE_UNKNOWN,
            FileType::Regular => ffi::G_FILE_TYPE_REGULAR,
            FileType::Directory => ffi::G_FILE_TYPE_DIRECTORY,
            FileType::SymbolicLink => ffi::G_FILE_TYPE_SYMBOLIC_LINK,
            FileType::Special => ffi::G_FILE_TYPE_SPECIAL,
            FileType::Shortcut => ffi::G_FILE_TYPE_SHORTCUT,
            FileType::Mountable => ffi::G_FILE_TYPE_MOUNTABLE,
            FileType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GFileType> for FileType {
    fn from_glib(value: ffi::GFileType) -> Self {
        match value {
            0 => FileType::Unknown,
            1 => FileType::Regular,
            2 => FileType::Directory,
            3 => FileType::SymbolicLink,
            4 => FileType::Special,
            5 => FileType::Shortcut,
            6 => FileType::Mountable,
            value => FileType::__Unknown(value),
        }
    }
}

impl StaticType for FileType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_file_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FileType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FileType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FileType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum IOErrorEnum {
    Failed,
    NotFound,
    Exists,
    IsDirectory,
    NotDirectory,
    NotEmpty,
    NotRegularFile,
    NotSymbolicLink,
    NotMountableFile,
    FilenameTooLong,
    InvalidFilename,
    TooManyLinks,
    NoSpace,
    InvalidArgument,
    PermissionDenied,
    NotSupported,
    NotMounted,
    AlreadyMounted,
    Closed,
    Cancelled,
    Pending,
    ReadOnly,
    CantCreateBackup,
    WrongEtag,
    TimedOut,
    WouldRecurse,
    Busy,
    WouldBlock,
    HostNotFound,
    WouldMerge,
    FailedHandled,
    TooManyOpenFiles,
    NotInitialized,
    AddressInUse,
    PartialInput,
    InvalidData,
    DbusError,
    HostUnreachable,
    NetworkUnreachable,
    ConnectionRefused,
    ProxyFailed,
    ProxyAuthFailed,
    ProxyNeedAuth,
    ProxyNotAllowed,
    BrokenPipe,
    NotConnected,
    MessageTooLarge,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for IOErrorEnum {
    type GlibType = ffi::GIOErrorEnum;

    fn to_glib(&self) -> ffi::GIOErrorEnum {
        match *self {
            IOErrorEnum::Failed => ffi::G_IO_ERROR_FAILED,
            IOErrorEnum::NotFound => ffi::G_IO_ERROR_NOT_FOUND,
            IOErrorEnum::Exists => ffi::G_IO_ERROR_EXISTS,
            IOErrorEnum::IsDirectory => ffi::G_IO_ERROR_IS_DIRECTORY,
            IOErrorEnum::NotDirectory => ffi::G_IO_ERROR_NOT_DIRECTORY,
            IOErrorEnum::NotEmpty => ffi::G_IO_ERROR_NOT_EMPTY,
            IOErrorEnum::NotRegularFile => ffi::G_IO_ERROR_NOT_REGULAR_FILE,
            IOErrorEnum::NotSymbolicLink => ffi::G_IO_ERROR_NOT_SYMBOLIC_LINK,
            IOErrorEnum::NotMountableFile => ffi::G_IO_ERROR_NOT_MOUNTABLE_FILE,
            IOErrorEnum::FilenameTooLong => ffi::G_IO_ERROR_FILENAME_TOO_LONG,
            IOErrorEnum::InvalidFilename => ffi::G_IO_ERROR_INVALID_FILENAME,
            IOErrorEnum::TooManyLinks => ffi::G_IO_ERROR_TOO_MANY_LINKS,
            IOErrorEnum::NoSpace => ffi::G_IO_ERROR_NO_SPACE,
            IOErrorEnum::InvalidArgument => ffi::G_IO_ERROR_INVALID_ARGUMENT,
            IOErrorEnum::PermissionDenied => ffi::G_IO_ERROR_PERMISSION_DENIED,
            IOErrorEnum::NotSupported => ffi::G_IO_ERROR_NOT_SUPPORTED,
            IOErrorEnum::NotMounted => ffi::G_IO_ERROR_NOT_MOUNTED,
            IOErrorEnum::AlreadyMounted => ffi::G_IO_ERROR_ALREADY_MOUNTED,
            IOErrorEnum::Closed => ffi::G_IO_ERROR_CLOSED,
            IOErrorEnum::Cancelled => ffi::G_IO_ERROR_CANCELLED,
            IOErrorEnum::Pending => ffi::G_IO_ERROR_PENDING,
            IOErrorEnum::ReadOnly => ffi::G_IO_ERROR_READ_ONLY,
            IOErrorEnum::CantCreateBackup => ffi::G_IO_ERROR_CANT_CREATE_BACKUP,
            IOErrorEnum::WrongEtag => ffi::G_IO_ERROR_WRONG_ETAG,
            IOErrorEnum::TimedOut => ffi::G_IO_ERROR_TIMED_OUT,
            IOErrorEnum::WouldRecurse => ffi::G_IO_ERROR_WOULD_RECURSE,
            IOErrorEnum::Busy => ffi::G_IO_ERROR_BUSY,
            IOErrorEnum::WouldBlock => ffi::G_IO_ERROR_WOULD_BLOCK,
            IOErrorEnum::HostNotFound => ffi::G_IO_ERROR_HOST_NOT_FOUND,
            IOErrorEnum::WouldMerge => ffi::G_IO_ERROR_WOULD_MERGE,
            IOErrorEnum::FailedHandled => ffi::G_IO_ERROR_FAILED_HANDLED,
            IOErrorEnum::TooManyOpenFiles => ffi::G_IO_ERROR_TOO_MANY_OPEN_FILES,
            IOErrorEnum::NotInitialized => ffi::G_IO_ERROR_NOT_INITIALIZED,
            IOErrorEnum::AddressInUse => ffi::G_IO_ERROR_ADDRESS_IN_USE,
            IOErrorEnum::PartialInput => ffi::G_IO_ERROR_PARTIAL_INPUT,
            IOErrorEnum::InvalidData => ffi::G_IO_ERROR_INVALID_DATA,
            IOErrorEnum::DbusError => ffi::G_IO_ERROR_DBUS_ERROR,
            IOErrorEnum::HostUnreachable => ffi::G_IO_ERROR_HOST_UNREACHABLE,
            IOErrorEnum::NetworkUnreachable => ffi::G_IO_ERROR_NETWORK_UNREACHABLE,
            IOErrorEnum::ConnectionRefused => ffi::G_IO_ERROR_CONNECTION_REFUSED,
            IOErrorEnum::ProxyFailed => ffi::G_IO_ERROR_PROXY_FAILED,
            IOErrorEnum::ProxyAuthFailed => ffi::G_IO_ERROR_PROXY_AUTH_FAILED,
            IOErrorEnum::ProxyNeedAuth => ffi::G_IO_ERROR_PROXY_NEED_AUTH,
            IOErrorEnum::ProxyNotAllowed => ffi::G_IO_ERROR_PROXY_NOT_ALLOWED,
            IOErrorEnum::BrokenPipe => ffi::G_IO_ERROR_BROKEN_PIPE,
            IOErrorEnum::NotConnected => ffi::G_IO_ERROR_NOT_CONNECTED,
            IOErrorEnum::MessageTooLarge => ffi::G_IO_ERROR_MESSAGE_TOO_LARGE,
            IOErrorEnum::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GIOErrorEnum> for IOErrorEnum {
    fn from_glib(value: ffi::GIOErrorEnum) -> Self {
        match value {
            0 => IOErrorEnum::Failed,
            1 => IOErrorEnum::NotFound,
            2 => IOErrorEnum::Exists,
            3 => IOErrorEnum::IsDirectory,
            4 => IOErrorEnum::NotDirectory,
            5 => IOErrorEnum::NotEmpty,
            6 => IOErrorEnum::NotRegularFile,
            7 => IOErrorEnum::NotSymbolicLink,
            8 => IOErrorEnum::NotMountableFile,
            9 => IOErrorEnum::FilenameTooLong,
            10 => IOErrorEnum::InvalidFilename,
            11 => IOErrorEnum::TooManyLinks,
            12 => IOErrorEnum::NoSpace,
            13 => IOErrorEnum::InvalidArgument,
            14 => IOErrorEnum::PermissionDenied,
            15 => IOErrorEnum::NotSupported,
            16 => IOErrorEnum::NotMounted,
            17 => IOErrorEnum::AlreadyMounted,
            18 => IOErrorEnum::Closed,
            19 => IOErrorEnum::Cancelled,
            20 => IOErrorEnum::Pending,
            21 => IOErrorEnum::ReadOnly,
            22 => IOErrorEnum::CantCreateBackup,
            23 => IOErrorEnum::WrongEtag,
            24 => IOErrorEnum::TimedOut,
            25 => IOErrorEnum::WouldRecurse,
            26 => IOErrorEnum::Busy,
            27 => IOErrorEnum::WouldBlock,
            28 => IOErrorEnum::HostNotFound,
            29 => IOErrorEnum::WouldMerge,
            30 => IOErrorEnum::FailedHandled,
            31 => IOErrorEnum::TooManyOpenFiles,
            32 => IOErrorEnum::NotInitialized,
            33 => IOErrorEnum::AddressInUse,
            34 => IOErrorEnum::PartialInput,
            35 => IOErrorEnum::InvalidData,
            36 => IOErrorEnum::DbusError,
            37 => IOErrorEnum::HostUnreachable,
            38 => IOErrorEnum::NetworkUnreachable,
            39 => IOErrorEnum::ConnectionRefused,
            40 => IOErrorEnum::ProxyFailed,
            41 => IOErrorEnum::ProxyAuthFailed,
            42 => IOErrorEnum::ProxyNeedAuth,
            43 => IOErrorEnum::ProxyNotAllowed,
            44 => IOErrorEnum::BrokenPipe,
            45 => IOErrorEnum::NotConnected,
            46 => IOErrorEnum::MessageTooLarge,
            value => IOErrorEnum::__Unknown(value),
        }
    }
}

impl ErrorDomain for IOErrorEnum {
    fn domain() -> glib_ffi::GQuark {
        unsafe { ffi::g_io_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(IOErrorEnum::Failed),
            1 => Some(IOErrorEnum::NotFound),
            2 => Some(IOErrorEnum::Exists),
            3 => Some(IOErrorEnum::IsDirectory),
            4 => Some(IOErrorEnum::NotDirectory),
            5 => Some(IOErrorEnum::NotEmpty),
            6 => Some(IOErrorEnum::NotRegularFile),
            7 => Some(IOErrorEnum::NotSymbolicLink),
            8 => Some(IOErrorEnum::NotMountableFile),
            9 => Some(IOErrorEnum::FilenameTooLong),
            10 => Some(IOErrorEnum::InvalidFilename),
            11 => Some(IOErrorEnum::TooManyLinks),
            12 => Some(IOErrorEnum::NoSpace),
            13 => Some(IOErrorEnum::InvalidArgument),
            14 => Some(IOErrorEnum::PermissionDenied),
            15 => Some(IOErrorEnum::NotSupported),
            16 => Some(IOErrorEnum::NotMounted),
            17 => Some(IOErrorEnum::AlreadyMounted),
            18 => Some(IOErrorEnum::Closed),
            19 => Some(IOErrorEnum::Cancelled),
            20 => Some(IOErrorEnum::Pending),
            21 => Some(IOErrorEnum::ReadOnly),
            22 => Some(IOErrorEnum::CantCreateBackup),
            23 => Some(IOErrorEnum::WrongEtag),
            24 => Some(IOErrorEnum::TimedOut),
            25 => Some(IOErrorEnum::WouldRecurse),
            26 => Some(IOErrorEnum::Busy),
            27 => Some(IOErrorEnum::WouldBlock),
            28 => Some(IOErrorEnum::HostNotFound),
            29 => Some(IOErrorEnum::WouldMerge),
            30 => Some(IOErrorEnum::FailedHandled),
            31 => Some(IOErrorEnum::TooManyOpenFiles),
            32 => Some(IOErrorEnum::NotInitialized),
            33 => Some(IOErrorEnum::AddressInUse),
            34 => Some(IOErrorEnum::PartialInput),
            35 => Some(IOErrorEnum::InvalidData),
            36 => Some(IOErrorEnum::DbusError),
            37 => Some(IOErrorEnum::HostUnreachable),
            38 => Some(IOErrorEnum::NetworkUnreachable),
            39 => Some(IOErrorEnum::ConnectionRefused),
            40 => Some(IOErrorEnum::ProxyFailed),
            41 => Some(IOErrorEnum::ProxyAuthFailed),
            42 => Some(IOErrorEnum::ProxyNeedAuth),
            43 => Some(IOErrorEnum::ProxyNotAllowed),
            44 => Some(IOErrorEnum::BrokenPipe),
            45 => Some(IOErrorEnum::NotConnected),
            46 => Some(IOErrorEnum::MessageTooLarge),
            _ => Some(IOErrorEnum::Failed),
        }
    }
}

impl StaticType for IOErrorEnum {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_io_error_enum_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for IOErrorEnum {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for IOErrorEnum {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for IOErrorEnum {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum MountOperationResult {
    Handled,
    Aborted,
    Unhandled,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for MountOperationResult {
    type GlibType = ffi::GMountOperationResult;

    fn to_glib(&self) -> ffi::GMountOperationResult {
        match *self {
            MountOperationResult::Handled => ffi::G_MOUNT_OPERATION_HANDLED,
            MountOperationResult::Aborted => ffi::G_MOUNT_OPERATION_ABORTED,
            MountOperationResult::Unhandled => ffi::G_MOUNT_OPERATION_UNHANDLED,
            MountOperationResult::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMountOperationResult> for MountOperationResult {
    fn from_glib(value: ffi::GMountOperationResult) -> Self {
        match value {
            0 => MountOperationResult::Handled,
            1 => MountOperationResult::Aborted,
            2 => MountOperationResult::Unhandled,
            value => MountOperationResult::__Unknown(value),
        }
    }
}

impl StaticType for MountOperationResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_mount_operation_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MountOperationResult {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MountOperationResult {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MountOperationResult {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NotificationPriority {
    Normal,
    Low,
    High,
    Urgent,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for NotificationPriority {
    type GlibType = ffi::GNotificationPriority;

    fn to_glib(&self) -> ffi::GNotificationPriority {
        match *self {
            NotificationPriority::Normal => ffi::G_NOTIFICATION_PRIORITY_NORMAL,
            NotificationPriority::Low => ffi::G_NOTIFICATION_PRIORITY_LOW,
            NotificationPriority::High => ffi::G_NOTIFICATION_PRIORITY_HIGH,
            NotificationPriority::Urgent => ffi::G_NOTIFICATION_PRIORITY_URGENT,
            NotificationPriority::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::GNotificationPriority> for NotificationPriority {
    fn from_glib(value: ffi::GNotificationPriority) -> Self {
        match value {
            0 => NotificationPriority::Normal,
            1 => NotificationPriority::Low,
            2 => NotificationPriority::High,
            3 => NotificationPriority::Urgent,
            value => NotificationPriority::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl StaticType for NotificationPriority {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_notification_priority_get_type()) }
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl<'a> FromValueOptional<'a> for NotificationPriority {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl<'a> FromValue<'a> for NotificationPriority {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl SetValue for NotificationPriority {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PasswordSave {
    Never,
    ForSession,
    Permanently,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PasswordSave {
    type GlibType = ffi::GPasswordSave;

    fn to_glib(&self) -> ffi::GPasswordSave {
        match *self {
            PasswordSave::Never => ffi::G_PASSWORD_SAVE_NEVER,
            PasswordSave::ForSession => ffi::G_PASSWORD_SAVE_FOR_SESSION,
            PasswordSave::Permanently => ffi::G_PASSWORD_SAVE_PERMANENTLY,
            PasswordSave::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GPasswordSave> for PasswordSave {
    fn from_glib(value: ffi::GPasswordSave) -> Self {
        match value {
            0 => PasswordSave::Never,
            1 => PasswordSave::ForSession,
            2 => PasswordSave::Permanently,
            value => PasswordSave::__Unknown(value),
        }
    }
}

impl StaticType for PasswordSave {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_password_save_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PasswordSave {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PasswordSave {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PasswordSave {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ResolverRecordType {
    Srv,
    Mx,
    Txt,
    Soa,
    Ns,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ResolverRecordType {
    type GlibType = ffi::GResolverRecordType;

    fn to_glib(&self) -> ffi::GResolverRecordType {
        match *self {
            ResolverRecordType::Srv => ffi::G_RESOLVER_RECORD_SRV,
            ResolverRecordType::Mx => ffi::G_RESOLVER_RECORD_MX,
            ResolverRecordType::Txt => ffi::G_RESOLVER_RECORD_TXT,
            ResolverRecordType::Soa => ffi::G_RESOLVER_RECORD_SOA,
            ResolverRecordType::Ns => ffi::G_RESOLVER_RECORD_NS,
            ResolverRecordType::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::GResolverRecordType> for ResolverRecordType {
    fn from_glib(value: ffi::GResolverRecordType) -> Self {
        match value {
            1 => ResolverRecordType::Srv,
            2 => ResolverRecordType::Mx,
            3 => ResolverRecordType::Txt,
            4 => ResolverRecordType::Soa,
            5 => ResolverRecordType::Ns,
            value => ResolverRecordType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl StaticType for ResolverRecordType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_resolver_record_type_get_type()) }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ResolverRecordType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl<'a> FromValue<'a> for ResolverRecordType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl SetValue for ResolverRecordType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ResourceError {
    NotFound,
    Internal,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ResourceError {
    type GlibType = ffi::GResourceError;

    fn to_glib(&self) -> ffi::GResourceError {
        match *self {
            ResourceError::NotFound => ffi::G_RESOURCE_ERROR_NOT_FOUND,
            ResourceError::Internal => ffi::G_RESOURCE_ERROR_INTERNAL,
            ResourceError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GResourceError> for ResourceError {
    fn from_glib(value: ffi::GResourceError) -> Self {
        match value {
            0 => ResourceError::NotFound,
            1 => ResourceError::Internal,
            value => ResourceError::__Unknown(value),
        }
    }
}

impl ErrorDomain for ResourceError {
    fn domain() -> glib_ffi::GQuark {
        unsafe { ffi::g_resource_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        match code {
            0 => Some(ResourceError::NotFound),
            1 => Some(ResourceError::Internal),
            value => Some(ResourceError::__Unknown(value)),
        }
    }
}

impl StaticType for ResourceError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_resource_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ResourceError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ResourceError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ResourceError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SocketClientEvent {
    Resolving,
    Resolved,
    Connecting,
    Connected,
    ProxyNegotiating,
    ProxyNegotiated,
    TlsHandshaking,
    TlsHandshaked,
    Complete,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SocketClientEvent {
    type GlibType = ffi::GSocketClientEvent;

    fn to_glib(&self) -> ffi::GSocketClientEvent {
        match *self {
            SocketClientEvent::Resolving => ffi::G_SOCKET_CLIENT_RESOLVING,
            SocketClientEvent::Resolved => ffi::G_SOCKET_CLIENT_RESOLVED,
            SocketClientEvent::Connecting => ffi::G_SOCKET_CLIENT_CONNECTING,
            SocketClientEvent::Connected => ffi::G_SOCKET_CLIENT_CONNECTED,
            SocketClientEvent::ProxyNegotiating => ffi::G_SOCKET_CLIENT_PROXY_NEGOTIATING,
            SocketClientEvent::ProxyNegotiated => ffi::G_SOCKET_CLIENT_PROXY_NEGOTIATED,
            SocketClientEvent::TlsHandshaking => ffi::G_SOCKET_CLIENT_TLS_HANDSHAKING,
            SocketClientEvent::TlsHandshaked => ffi::G_SOCKET_CLIENT_TLS_HANDSHAKED,
            SocketClientEvent::Complete => ffi::G_SOCKET_CLIENT_COMPLETE,
            SocketClientEvent::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketClientEvent> for SocketClientEvent {
    fn from_glib(value: ffi::GSocketClientEvent) -> Self {
        match value {
            0 => SocketClientEvent::Resolving,
            1 => SocketClientEvent::Resolved,
            2 => SocketClientEvent::Connecting,
            3 => SocketClientEvent::Connected,
            4 => SocketClientEvent::ProxyNegotiating,
            5 => SocketClientEvent::ProxyNegotiated,
            6 => SocketClientEvent::TlsHandshaking,
            7 => SocketClientEvent::TlsHandshaked,
            8 => SocketClientEvent::Complete,
            value => SocketClientEvent::__Unknown(value),
        }
    }
}

impl StaticType for SocketClientEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_client_event_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SocketClientEvent {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SocketClientEvent {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SocketClientEvent {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SocketFamily {
    Invalid,
    Unix,
    Ipv4,
    Ipv6,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SocketFamily {
    type GlibType = ffi::GSocketFamily;

    fn to_glib(&self) -> ffi::GSocketFamily {
        match *self {
            SocketFamily::Invalid => ffi::G_SOCKET_FAMILY_INVALID,
            SocketFamily::Unix => ffi::G_SOCKET_FAMILY_UNIX,
            SocketFamily::Ipv4 => ffi::G_SOCKET_FAMILY_IPV4,
            SocketFamily::Ipv6 => ffi::G_SOCKET_FAMILY_IPV6,
            SocketFamily::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketFamily> for SocketFamily {
    fn from_glib(value: ffi::GSocketFamily) -> Self {
        match value {
            0 => SocketFamily::Invalid,
            1 => SocketFamily::Unix,
            2 => SocketFamily::Ipv4,
            10 => SocketFamily::Ipv6,
            value => SocketFamily::__Unknown(value),
        }
    }
}

impl StaticType for SocketFamily {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_family_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SocketFamily {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SocketFamily {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SocketFamily {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_46", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SocketListenerEvent {
    Binding,
    Bound,
    Listening,
    Listened,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_46", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for SocketListenerEvent {
    type GlibType = ffi::GSocketListenerEvent;

    fn to_glib(&self) -> ffi::GSocketListenerEvent {
        match *self {
            SocketListenerEvent::Binding => ffi::G_SOCKET_LISTENER_BINDING,
            SocketListenerEvent::Bound => ffi::G_SOCKET_LISTENER_BOUND,
            SocketListenerEvent::Listening => ffi::G_SOCKET_LISTENER_LISTENING,
            SocketListenerEvent::Listened => ffi::G_SOCKET_LISTENER_LISTENED,
            SocketListenerEvent::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_46", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::GSocketListenerEvent> for SocketListenerEvent {
    fn from_glib(value: ffi::GSocketListenerEvent) -> Self {
        match value {
            0 => SocketListenerEvent::Binding,
            1 => SocketListenerEvent::Bound,
            2 => SocketListenerEvent::Listening,
            3 => SocketListenerEvent::Listened,
            value => SocketListenerEvent::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_46", feature = "dox"))]
impl StaticType for SocketListenerEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_listener_event_get_type()) }
    }
}

#[cfg(any(feature = "v2_46", feature = "dox"))]
impl<'a> FromValueOptional<'a> for SocketListenerEvent {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_46", feature = "dox"))]
impl<'a> FromValue<'a> for SocketListenerEvent {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_46", feature = "dox"))]
impl SetValue for SocketListenerEvent {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SocketProtocol {
    Unknown,
    Default,
    Tcp,
    Udp,
    Sctp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SocketProtocol {
    type GlibType = ffi::GSocketProtocol;

    fn to_glib(&self) -> ffi::GSocketProtocol {
        match *self {
            SocketProtocol::Unknown => ffi::G_SOCKET_PROTOCOL_UNKNOWN,
            SocketProtocol::Default => ffi::G_SOCKET_PROTOCOL_DEFAULT,
            SocketProtocol::Tcp => ffi::G_SOCKET_PROTOCOL_TCP,
            SocketProtocol::Udp => ffi::G_SOCKET_PROTOCOL_UDP,
            SocketProtocol::Sctp => ffi::G_SOCKET_PROTOCOL_SCTP,
            SocketProtocol::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketProtocol> for SocketProtocol {
    fn from_glib(value: ffi::GSocketProtocol) -> Self {
        match value {
            -1 => SocketProtocol::Unknown,
            0 => SocketProtocol::Default,
            6 => SocketProtocol::Tcp,
            17 => SocketProtocol::Udp,
            132 => SocketProtocol::Sctp,
            value => SocketProtocol::__Unknown(value),
        }
    }
}

impl StaticType for SocketProtocol {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_protocol_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SocketProtocol {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SocketProtocol {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SocketProtocol {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SocketType {
    Invalid,
    Stream,
    Datagram,
    Seqpacket,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SocketType {
    type GlibType = ffi::GSocketType;

    fn to_glib(&self) -> ffi::GSocketType {
        match *self {
            SocketType::Invalid => ffi::G_SOCKET_TYPE_INVALID,
            SocketType::Stream => ffi::G_SOCKET_TYPE_STREAM,
            SocketType::Datagram => ffi::G_SOCKET_TYPE_DATAGRAM,
            SocketType::Seqpacket => ffi::G_SOCKET_TYPE_SEQPACKET,
            SocketType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GSocketType> for SocketType {
    fn from_glib(value: ffi::GSocketType) -> Self {
        match value {
            0 => SocketType::Invalid,
            1 => SocketType::Stream,
            2 => SocketType::Datagram,
            3 => SocketType::Seqpacket,
            value => SocketType::__Unknown(value),
        }
    }
}

impl StaticType for SocketType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_socket_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SocketType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SocketType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SocketType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TlsAuthenticationMode {
    None,
    Requested,
    Required,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TlsAuthenticationMode {
    type GlibType = ffi::GTlsAuthenticationMode;

    fn to_glib(&self) -> ffi::GTlsAuthenticationMode {
        match *self {
            TlsAuthenticationMode::None => ffi::G_TLS_AUTHENTICATION_NONE,
            TlsAuthenticationMode::Requested => ffi::G_TLS_AUTHENTICATION_REQUESTED,
            TlsAuthenticationMode::Required => ffi::G_TLS_AUTHENTICATION_REQUIRED,
            TlsAuthenticationMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsAuthenticationMode> for TlsAuthenticationMode {
    fn from_glib(value: ffi::GTlsAuthenticationMode) -> Self {
        match value {
            0 => TlsAuthenticationMode::None,
            1 => TlsAuthenticationMode::Requested,
            2 => TlsAuthenticationMode::Required,
            value => TlsAuthenticationMode::__Unknown(value),
        }
    }
}

impl StaticType for TlsAuthenticationMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_authentication_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TlsAuthenticationMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TlsAuthenticationMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TlsAuthenticationMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_40", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TlsCertificateRequestFlags {
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_40", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for TlsCertificateRequestFlags {
    type GlibType = ffi::GTlsCertificateRequestFlags;

    fn to_glib(&self) -> ffi::GTlsCertificateRequestFlags {
        match *self {
            TlsCertificateRequestFlags::None => ffi::G_TLS_CERTIFICATE_REQUEST_NONE,
            TlsCertificateRequestFlags::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_40", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::GTlsCertificateRequestFlags> for TlsCertificateRequestFlags {
    fn from_glib(value: ffi::GTlsCertificateRequestFlags) -> Self {
        match value {
            0 => TlsCertificateRequestFlags::None,
            value => TlsCertificateRequestFlags::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_40", feature = "dox"))]
impl StaticType for TlsCertificateRequestFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_certificate_request_flags_get_type()) }
    }
}

#[cfg(any(feature = "v2_40", feature = "dox"))]
impl<'a> FromValueOptional<'a> for TlsCertificateRequestFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_40", feature = "dox"))]
impl<'a> FromValue<'a> for TlsCertificateRequestFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_40", feature = "dox"))]
impl SetValue for TlsCertificateRequestFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TlsDatabaseLookupFlags {
    None,
    Keypair,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TlsDatabaseLookupFlags {
    type GlibType = ffi::GTlsDatabaseLookupFlags;

    fn to_glib(&self) -> ffi::GTlsDatabaseLookupFlags {
        match *self {
            TlsDatabaseLookupFlags::None => ffi::G_TLS_DATABASE_LOOKUP_NONE,
            TlsDatabaseLookupFlags::Keypair => ffi::G_TLS_DATABASE_LOOKUP_KEYPAIR,
            TlsDatabaseLookupFlags::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsDatabaseLookupFlags> for TlsDatabaseLookupFlags {
    fn from_glib(value: ffi::GTlsDatabaseLookupFlags) -> Self {
        match value {
            0 => TlsDatabaseLookupFlags::None,
            1 => TlsDatabaseLookupFlags::Keypair,
            value => TlsDatabaseLookupFlags::__Unknown(value),
        }
    }
}

impl StaticType for TlsDatabaseLookupFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_database_lookup_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TlsDatabaseLookupFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TlsDatabaseLookupFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TlsDatabaseLookupFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TlsInteractionResult {
    Unhandled,
    Handled,
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TlsInteractionResult {
    type GlibType = ffi::GTlsInteractionResult;

    fn to_glib(&self) -> ffi::GTlsInteractionResult {
        match *self {
            TlsInteractionResult::Unhandled => ffi::G_TLS_INTERACTION_UNHANDLED,
            TlsInteractionResult::Handled => ffi::G_TLS_INTERACTION_HANDLED,
            TlsInteractionResult::Failed => ffi::G_TLS_INTERACTION_FAILED,
            TlsInteractionResult::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsInteractionResult> for TlsInteractionResult {
    fn from_glib(value: ffi::GTlsInteractionResult) -> Self {
        match value {
            0 => TlsInteractionResult::Unhandled,
            1 => TlsInteractionResult::Handled,
            2 => TlsInteractionResult::Failed,
            value => TlsInteractionResult::__Unknown(value),
        }
    }
}

impl StaticType for TlsInteractionResult {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_interaction_result_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TlsInteractionResult {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TlsInteractionResult {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TlsInteractionResult {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TlsRehandshakeMode {
    Never,
    Safely,
    Unsafely,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TlsRehandshakeMode {
    type GlibType = ffi::GTlsRehandshakeMode;

    fn to_glib(&self) -> ffi::GTlsRehandshakeMode {
        match *self {
            TlsRehandshakeMode::Never => ffi::G_TLS_REHANDSHAKE_NEVER,
            TlsRehandshakeMode::Safely => ffi::G_TLS_REHANDSHAKE_SAFELY,
            TlsRehandshakeMode::Unsafely => ffi::G_TLS_REHANDSHAKE_UNSAFELY,
            TlsRehandshakeMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GTlsRehandshakeMode> for TlsRehandshakeMode {
    fn from_glib(value: ffi::GTlsRehandshakeMode) -> Self {
        match value {
            0 => TlsRehandshakeMode::Never,
            1 => TlsRehandshakeMode::Safely,
            2 => TlsRehandshakeMode::Unsafely,
            value => TlsRehandshakeMode::__Unknown(value),
        }
    }
}

impl StaticType for TlsRehandshakeMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::g_tls_rehandshake_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TlsRehandshakeMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TlsRehandshakeMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TlsRehandshakeMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

